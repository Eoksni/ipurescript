# Önerilmez olarak işaretlenmiş!
# Kernel = import '/IPython/kernel/zmq/kernelbase/Kernel'
# Kernel = import '/ipykernel/kernelbase/Kernel'
Kernel = import '/ipykernel/ipkernel/IPythonKernel'

sys = import '/sys'
Compiler = import '/dg/Compiler'
BUILTINS = import '/dg/BUILTINS'
dg = import '/dg'
capture = import '/IPython/utils/capture'
comm = import '/ipykernel/comm'
[CommManager, Comm] = [comm.CommManager, comm.Comm]
Widget = import '/ipywidgets/Widget'
tokenutil = import '/IPython/utils/tokenutil'
BytesIO = import '/io/BytesIO'
Figure = import '/matplotlib/figure/Figure'
urllib = import '/urllib'
base64 = import '/base64'

IdgKernel = subclass Kernel where
    #: Ütopik bir çekirdek girişimi.
    #:
    implementation = 'Idg'
    implementation_version = '1.0'
    display_name = 'dg-9'
    language = 'dg'
    language_info = ({('name', 'Dg'), ('mimetype', 'text/dg'), ('file_extension', '.dg'), ('codemirror_mode', {('name', 'python')}), ('pygments_lexer', 'ipython3')})
    language_version = '1.1.0' #??
    banner = "Dg will rule the Doges."

    _execution_count = 0 # Should I really do that??
    error_flag = False
    e_ = None

    __complete_word = word ~>
        path, dot, word = word.rpartition '.'
        completion_ns = (sys.modules !! '__main__') |>.__dict__
        sorted $ map (path + dot +) $
            # Hide private attributes unless an underscore was typed.
            filter (w -> w.startswith word and (word or not (w.startswith '_'))) $ if
                not path  => set Compiler.prefix | set BUILTINS | set completion_ns
                otherwise => except
                    err => dir $ eval path completion_ns
                    err `isinstance` Exception => []

    # Init?
    __init__ = *: args **: kwargs ~>
        @@__init__ **: kwargs
        @comm_manager = CommManager parent: self kernel: self
        @comm_manager.register_target 'jupyter.widget' Widget.handle_comm_opened
        @comm = Comm target_name:'jupyter.widget'
        None

    to_response = context to: 'stdout' ~>
      {('name', to), ('text', context)}

    eval_ = code module: None ~>
          compiled_ = dg.compile code '<file>'
          if
            module is None => eval compiled_
            otherwise => eval compiled_ module

    to_png = fig_ ~>
      imgdata_ = BytesIO!
      fig_.savefig imgdata_ format:'png'
      imgdata_.seek 0
      urllib.parse.quote (base64.b64encode (imgdata_.getvalue!))


    do_execute = code silent store_history: True user_expressions: None allow_stdin: False ~>
        if not silent =>
            except
                err_ => with @captured_output_ = capture.capture_output! => @evalresult_ = @eval_ code (globals!)
                err_ :: ValueError => @send_response @iopub_socket 'stream' (@to_response @captured_output_.stderr to: 'stderr')
                err_ is None =>
                    @_execution_count = @_execution_count + 1
                    @send_response @iopub_socket 'stream' (@to_response (if not (@evalresult_ is None) => (str @evalresult_)))
                    @send_response @iopub_socket 'stream' (@to_response @captured_output_.stdout)
                    for output_ in @captured_output_.outputs => @send_response @iopub_socket 'display_data' output_.__dict__
                    if @evalresult_ :: Figure =>
                        [width_, height_] = @evalresult_.get_size_inches!
                        dpi_ = @evalresult_.dpi
                        @send_response @iopub_socket 'display_data' {('source', 'kernel'), ('data', {('image/png', (@to_png @evalresult_))}), ('metadata', {('image/png', {('width', width_ * dpi_), ('height', height_ * dpi_)})})}
        {('status', 'ok'), ('execution_count', @_execution_count), ('payload', list!), ('user_expressions', dict!)}

    do_complete = code_ cursor_position_ ~>
      if cursor_position_ is None => cursor_position_ = len code_
      [line_, offset_] = tokenutil.line_at_cursor code_ cursor_position_
      line_cursor_ = cursor_position_ - offset_
      completion_results_ = @__complete_word line_
      dict status: 'ok' matches: completion_results_ cursor_start: (cursor_position_ - (len line_)) cursor_end: cursor_position_ metadata: dict!
